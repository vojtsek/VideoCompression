<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Distributed Video Encoding: NetworkHandler Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Distributed Video Encoding
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classNetworkHandler-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">NetworkHandler Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="structNetworkHandler.html" title="The NetworkHandler struct provides several methods to handle network related stuffs also holds adress...">NetworkHandler</a> struct provides several methods to handle network related stuffs also holds adresses of potential neighbors.  
 <a href="structNetworkHandler.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="NetworkHandler_8h_source.html">NetworkHandler.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac692e9f510aa53defae7a48e4bef6927"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNetworkHandler.html#ac692e9f510aa53defae7a48e4bef6927">spawnOutgoingConnection</a> (struct sockaddr_storage addr, int64_t fd, std::vector&lt; CMDS &gt; cmds, bool async, void *data)</td></tr>
<tr class="memdesc:ac692e9f510aa53defae7a48e4bef6927"><td class="mdescLeft">&#160;</td><td class="mdescRight">spawnOutgoingConnection spawns communication with the given address  <a href="#ac692e9f510aa53defae7a48e4bef6927">More...</a><br /></td></tr>
<tr class="separator:ac692e9f510aa53defae7a48e4bef6927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87551cf7a21f263405095213731a4239"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNetworkHandler.html#a87551cf7a21f263405095213731a4239">spawnIncomingConnection</a> (struct sockaddr_storage addr, int64_t fd, bool async)</td></tr>
<tr class="memdesc:a87551cf7a21f263405095213731a4239"><td class="mdescLeft">&#160;</td><td class="mdescRight">handles incoming communication  <a href="#a87551cf7a21f263405095213731a4239">More...</a><br /></td></tr>
<tr class="separator:a87551cf7a21f263405095213731a4239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8771f6d8f704ebc99fc0b8551ecf3d"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNetworkHandler.html#abf8771f6d8f704ebc99fc0b8551ecf3d">start_listening</a> (int64_t port)</td></tr>
<tr class="memdesc:abf8771f6d8f704ebc99fc0b8551ecf3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">start_listening starts listening on the given port  <a href="#abf8771f6d8f704ebc99fc0b8551ecf3d">More...</a><br /></td></tr>
<tr class="separator:abf8771f6d8f704ebc99fc0b8551ecf3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc464fcb00753d4ce8d392cf5c00b7f1"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNetworkHandler.html#acc464fcb00753d4ce8d392cf5c00b7f1">checkNeighbor</a> (struct sockaddr_storage addr)</td></tr>
<tr class="memdesc:acc464fcb00753d4ce8d392cf5c00b7f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">checkNeighbor checks status of the given neighbor  <a href="#acc464fcb00753d4ce8d392cf5c00b7f1">More...</a><br /></td></tr>
<tr class="separator:acc464fcb00753d4ce8d392cf5c00b7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f06041f2627ed2496a81fc5b68e4540"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNetworkHandler.html#a7f06041f2627ed2496a81fc5b68e4540">getPotentialNeighborsCount</a> ()</td></tr>
<tr class="memdesc:a7f06041f2627ed2496a81fc5b68e4540"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets count of potential neighbors  <a href="#a7f06041f2627ed2496a81fc5b68e4540">More...</a><br /></td></tr>
<tr class="separator:a7f06041f2627ed2496a81fc5b68e4540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99421292375096f829389a522d5828e"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNetworkHandler.html#ab99421292375096f829389a522d5828e">connectPeer</a> (struct sockaddr_storage *addr)</td></tr>
<tr class="memdesc:ab99421292375096f829389a522d5828e"><td class="mdescLeft">&#160;</td><td class="mdescRight">connectPeer makes connection to the desired peer  <a href="#ab99421292375096f829389a522d5828e">More...</a><br /></td></tr>
<tr class="separator:ab99421292375096f829389a522d5828e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d77e3b211d3c181ed20b3253d8d5a7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNetworkHandler.html#a3d77e3b211d3c181ed20b3253d8d5a7f">confirmNeighbor</a> (struct sockaddr_storage addr)</td></tr>
<tr class="memdesc:a3d77e3b211d3c181ed20b3253d8d5a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">confirmNeighbor connect to a remote peer and spawns Confirm command  <a href="#a3d77e3b211d3c181ed20b3253d8d5a7f">More...</a><br /></td></tr>
<tr class="separator:a3d77e3b211d3c181ed20b3253d8d5a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5ab05a1e9aedfc7d9fd1bf7ff99a86"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e5ab05a1e9aedfc7d9fd1bf7ff99a86"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNetworkHandler.html#a2e5ab05a1e9aedfc7d9fd1bf7ff99a86">obtainNeighbors</a> ()</td></tr>
<tr class="memdesc:a2e5ab05a1e9aedfc7d9fd1bf7ff99a86"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtainNeighbors tries to gain more neighbors to the list If potential neighbor is available, tries to confirm him, othewise first tries to gain some potential neighbors using collectNeighbors <br /></td></tr>
<tr class="separator:a2e5ab05a1e9aedfc7d9fd1bf7ff99a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca89bb0d67777ee8e39bd71e025e9c28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNetworkHandler.html#aca89bb0d67777ee8e39bd71e025e9c28">gatherNeighbors</a> (int64_t TTL, const struct sockaddr_storage &amp;requester_addr, const struct sockaddr_storage &amp;ngh_addr)</td></tr>
<tr class="memdesc:aca89bb0d67777ee8e39bd71e025e9c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">gatherNeighbors spreads the request message  <a href="#aca89bb0d67777ee8e39bd71e025e9c28">More...</a><br /></td></tr>
<tr class="separator:aca89bb0d67777ee8e39bd71e025e9c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8837b0207462ab32fe3ee4c0623de3f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8837b0207462ab32fe3ee4c0623de3f1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNetworkHandler.html#a8837b0207462ab32fe3ee4c0623de3f1">collectNeighbors</a> ()</td></tr>
<tr class="memdesc:a8837b0207462ab32fe3ee4c0623de3f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">collectNeighbors tries to collect more potential neighbors contacts neighbor, if any, or superpeer asks for new adresses different from gather neighbors <br /></td></tr>
<tr class="separator:a8837b0207462ab32fe3ee4c0623de3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be31cea2af22fb0b07c81975d3a13fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5be31cea2af22fb0b07c81975d3a13fe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNetworkHandler.html#a5be31cea2af22fb0b07c81975d3a13fe">contactSuperPeer</a> ()</td></tr>
<tr class="memdesc:a5be31cea2af22fb0b07c81975d3a13fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">pings the super peer Contacts the superpeer and pings it invoked periodically <br /></td></tr>
<tr class="separator:a5be31cea2af22fb0b07c81975d3a13fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df8cbc634881c740a1cd3e5066329ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNetworkHandler.html#a4df8cbc634881c740a1cd3e5066329ef">askForAddresses</a> (const struct sockaddr_storage &amp;addr)</td></tr>
<tr class="memdesc:a4df8cbc634881c740a1cd3e5066329ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">askForAddresses sends a request for new neighbors  <a href="#a4df8cbc634881c740a1cd3e5066329ef">More...</a><br /></td></tr>
<tr class="separator:a4df8cbc634881c740a1cd3e5066329ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4944a0f94434607370ca469fa5f45f61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNetworkHandler.html#a4944a0f94434607370ca469fa5f45f61">addNewNeighbor</a> (bool potential, const struct sockaddr_storage &amp;addr)</td></tr>
<tr class="memdesc:a4944a0f94434607370ca469fa5f45f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">addNewNeighbor adds new neighbors to the list  <a href="#a4944a0f94434607370ca469fa5f45f61">More...</a><br /></td></tr>
<tr class="separator:a4944a0f94434607370ca469fa5f45f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:abbcb8d426f15c3c7b8f8ead6ae2756c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abbcb8d426f15c3c7b8f8ead6ae2756c6"></a>
std::vector&lt; struct sockaddr_storage &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNetworkHandler.html#abbcb8d426f15c3c7b8f8ead6ae2756c6">potential_neighbors</a></td></tr>
<tr class="memdesc:abbcb8d426f15c3c7b8f8ead6ae2756c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">potential neighbors - addresses to contact <br /></td></tr>
<tr class="separator:abbcb8d426f15c3c7b8f8ead6ae2756c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28dc69e79bb59384914d7865701f965"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad28dc69e79bb59384914d7865701f965"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNetworkHandler.html#ad28dc69e79bb59384914d7865701f965">potential_mtx</a></td></tr>
<tr class="memdesc:ad28dc69e79bb59384914d7865701f965"><td class="mdescLeft">&#160;</td><td class="mdescRight">to synchronize access to potential neighbors <br /></td></tr>
<tr class="separator:ad28dc69e79bb59384914d7865701f965"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="structNetworkHandler.html" title="The NetworkHandler struct provides several methods to handle network related stuffs also holds adress...">NetworkHandler</a> struct provides several methods to handle network related stuffs also holds adresses of potential neighbors. </p>
<p>externaly defined class </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4944a0f94434607370ca469fa5f45f61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetworkHandler::addNewNeighbor </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>potential</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr_storage &amp;&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>addNewNeighbor adds new neighbors to the list </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">potential</td><td>whether the neighbor is potential </td></tr>
    <tr><td class="paramname">addr</td><td>address of the neighbors adds the given neighbor to a list in <a class="el" href="classNeighborStorage.html" title="The NeighborStorage class maintains the neighbors Provides interface to work with the list of neighbo...">NeighborStorage</a> or adds it to the potential neighbors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4df8cbc634881c740a1cd3e5066329ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetworkHandler::askForAddresses </td>
          <td>(</td>
          <td class="paramtype">const struct sockaddr_storage &amp;&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>askForAddresses sends a request for new neighbors </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>address of the neighbor which should be asked Makes a connection and invokes the CmdAsk command, which should obtain new addresses. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc464fcb00753d4ce8d392cf5c00b7f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t NetworkHandler::checkNeighbor </td>
          <td>(</td>
          <td class="paramtype">struct sockaddr_storage&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checkNeighbor checks status of the given neighbor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>address of the neighbor to be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>on success, file descriptor of the connection, -1 otherwise Tries to connect to the neighbor. If fails, removes the neighbor, otherwise updates neighbor information and returns the file descriptor associated with the connection. </dd></dl>

</div>
</div>
<a class="anchor" id="a3d77e3b211d3c181ed20b3253d8d5a7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetworkHandler::confirmNeighbor </td>
          <td>(</td>
          <td class="paramtype">struct sockaddr_storage&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>confirmNeighbor connect to a remote peer and spawns Confirm command </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>address of the neighbor to be confirmed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab99421292375096f829389a522d5828e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t NetworkHandler::connectPeer </td>
          <td>(</td>
          <td class="paramtype">struct sockaddr_storage *&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>connectPeer makes connection to the desired peer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>network address structure to connect to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>file descriptor of the connection </dd></dl>

</div>
</div>
<a class="anchor" id="aca89bb0d67777ee8e39bd71e025e9c28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetworkHandler::gatherNeighbors </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>TTL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr_storage &amp;&#160;</td>
          <td class="paramname"><em>requester_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr_storage &amp;&#160;</td>
          <td class="paramname"><em>ngh_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gatherNeighbors spreads the request message </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TTL</td><td>how many hops to make </td></tr>
    <tr><td class="paramname">requester_addr</td><td>address of the node which is requesting </td></tr>
    <tr><td class="paramname">ngh_addr</td><td>address to send, next hop handles sending the request to next neighbor, however ain logic in the CmdGather* </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7f06041f2627ed2496a81fc5b68e4540"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t NetworkHandler::getPotentialNeighborsCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets count of potential neighbors </p>
<dl class="section return"><dt>Returns</dt><dd>count of pot. neighbors </dd></dl>

</div>
</div>
<a class="anchor" id="a87551cf7a21f263405095213731a4239"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetworkHandler::spawnIncomingConnection </td>
          <td>(</td>
          <td class="paramtype">struct sockaddr_storage&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>async</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>handles incoming communication </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>address with which it should communicate </td></tr>
    <tr><td class="paramname">fd</td><td>file descriptor associated with the connection </td></tr>
    <tr><td class="paramname">async</td><td>whether the connection should be asynchronous The method is called, given a file descriptor obtained from accepted connection Waits for CMDS type to be received and tries to map it to a command and execute it. Fails otherwise. Runs in separate thread, closes the fd eventually. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac692e9f510aa53defae7a48e4bef6927"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetworkHandler::spawnOutgoingConnection </td>
          <td>(</td>
          <td class="paramtype">struct sockaddr_storage&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; CMDS &gt;&#160;</td>
          <td class="paramname"><em>cmds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>async</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>spawnOutgoingConnection spawns communication with the given address </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>address with which it should communicate </td></tr>
    <tr><td class="paramname">fd</td><td>file descriptor associated with the connection </td></tr>
    <tr><td class="paramname">cmds</td><td>vector of commands that should be processed </td></tr>
    <tr><td class="paramname">async</td><td>whether the connection should be asynchronous </td></tr>
    <tr><td class="paramname">data</td><td>pointer to data commands are supposed to access The method is called when a connection with some remote peer is created, handles sending the commands provided, ensures correct communication with the other side. Each command runs and its result determines what next. The controlling routine is spawned in the separate thread, if async, this thread is then detached. Finally, the fd is closed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abf8771f6d8f704ebc99fc0b8551ecf3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t NetworkHandler::start_listening </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>start_listening starts listening on the given port </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>port number with which should be the listening socket bound </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 on failure Creates the socket, binds it and starts listening on the given port. Incoming connection are handled using spawnIncomingConnection call. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>structures/<a class="el" href="NetworkHandler_8h_source.html">NetworkHandler.h</a></li>
<li>structures/NetworkHandler.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
